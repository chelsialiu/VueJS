<!DOCTYPE html>
 <html class="no-js">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>VueJS</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script src="vue.js"></script>
        <!-- <link rel="stylesheet" href=""> -->
    </head>
    <body>
        <h1 style='text-align: center;'>Chelsia's VueJS Project -- Using VueJS to Interact with the DOM</h1>
        <div id="app">
            <p>SIMPLE VUE.JS APPLICATION</p>
            The title will change according to what you type into the input box:
            <div>
                <br>
                <input type="text" v-on:input="changeTitle">
                <p>Title: {{ title }}</p>
            </div>
            <hr>

            <p>ACCESSING DATA IN THE VUE INSTANCE</p>
            We can access and display data from our Vue instance in our HTML code:
            <p>{{ sayHello() }}</p>
            <hr>

            <p>BINDING TO ATTRIBUTES</p>
            We can use the directive <i>v-bind</i> to bind data from our Vue instance to the HTML attributes:
            <p><a v-bind:href='link' target='_blank'>Google</a></p>
            <hr>

            <p>DISABLE RE-RENDERING</p>
            We can use the directive <i>v-once</i> to display the original value of a Vue instance attribute instead of the overwritten value (which might have occurred previously):
            <p v-once>This is the original title: {{ title }}</p>
            <hr>

            <p>HOW TO OUTPUT RAW HTML</p>
            We can use the directive <i>v-html</i> to say render HTML code and not escape it: 
            <p v-html='finishedLink'></p>
            <hr>

            <p>LISTENING TO EVENTS</p>
            We can use the directive <i>v-on</i> to listen to events and respond in a certain way. This "Click Me" button utilitizes <i>v-on:click</i>, which is similar to  JS onclick function:
            <div>
                <br>
                <button v-on:click='increaseCounter'>Click me</button> <!--v-on has access to all default DOM events, not only click-->
                <p>{{ counter }}</p>
            </div>
            <hr>

            <p>GETTING EVENT DATA FROM THE EVENT OBJECT</p>
            <p>We can access and use event data from the event object. Here, we are accessing the updateCoordinates function and displaying the coordinates of the computer mouse on the screen.</p>
            <p>We can also modify and event (such as stopping propagation), and change certain attributes. In this case, we create a "Dead Spot" where the coordinates stop updating:</p>
            <p v-on:mousemove='updateCoordinates'>
                Coordinates: {{ x }} / {{ y }}
                - <span v-on:mousemove.stop=''>DEAD SPOT</span>
            </p>
            <hr>

            <p>KEYBOARD EVENTS</p>
            We can add key modifiers for v-on when listening for key events.
            <p>By using <i>v-on:keyup.enter.space</i>, an alert box will pop up if you hit "Enter" or "Space" on the keyboard:</p>
            <input type='text' v-on:keyup.enter.space='alertMe'> <!--Alert will pop up when 'Enter' or 'Space' are hit on the keyboard-->
            <hr>

            <p>USING TWO-WAY BINDING</p>
            With two-way binding, we can link attriubutes <i>(v-bind)</i> and also listen for events <i>(v-on></i>.
            Here, you type something into the input box, the data will also update and display:
            <div>
                <br>
                <input type='text' v-model='name'>
                <p>Data text: {{ name }}</p>
            </div>
            <hr>

            <p>WRITING JAVASCRIPT CODE IN THE TEMPLATES</p>
            In Vue.js, we can execute Javascript code by either writing a Vue <i>method</i> or by adding a Vue <i>computed property</i>. 
            The "Increase" and "Decrease" buttons utilize the Vue <i>method</i>, and the "Increase Second" button utilitizes the Vue <i>computed property</i>.
            Both are similar, but a <i>computed property</i> is stored/used as a property of the data objects and is cached, not recalculated.
            <div>
                <br>
                <button v-on:click='counter2++'>Increase</button>
                <button v-on:click='counter2--'>Decrease</button>
                <button v-on:click='counter3++'>Increase Second</button>
                <p>Counter (method): {{ counter2 }} | Counter (computed property): {{ counter3 }}</p>
                <p>Result (method): {{ result() }} | Result (computed property): {{ output }}</p>
            </div>
            <hr>

            <p>REACTING TO CHANGES WITH COMPUTED PROPERTIES</p>
            We can use the data <i>watch</i> object to watch the "counter" property and specify what code should execute when the value of "counter" changes.
            For this exercise, we reset the counter to "0" every three seconds.
            <div>
                <br>
                <button v-on:click='counter4++'>Increase</button>
                <button v-on:click='counter4--'>Decrease</button>
                <p>Counter: {{ counter4 }}</p>
            </div>
            <hr>


        </div>
    </body>
    <script>
        new Vue ({
            el: '#app',
            data: {
                title: "Hello World!",
                sayHelloTitle: "",
                link: "http://google.com",
                finishedLink: "<a href='http://google.com' target='_blank'>Google</a>",
                counter: 0,
                counter2: 0,
                counter3: 0,
                counter4: 0,
                x: 0,
                y: 0,
                name: 'Chelsia'
            },
            computed: {
              output: function() {
                  console.log("Computed");
                return this.counter3 > 5 ? "Greater than 5" : "Less than 5";
              }  
            },
            watch: {
                counter4: function(value) {
                    var vm = this;
                    setTimeout(function() { // closed function in callback requires us to store "this" Vue instance in the vm variable
                        vm.counter4 = 0;
                    }, 3000)
                }
            },
            methods: {
                changeTitle: function(event) {
                    this.title = event.target.value;
                },
                sayHello: function() {
                    this.sayHelloTitle = "This text is from my 'sayHello function' inside of my Vue instance!";
                    return this.sayHelloTitle;
                },
                increaseCounter: function() {
                    this.counter++;
                },
                updateCoordinates: function(event) {
                    this.x = event.clientX;
                    this.y = event.clientY;
                },
                alertMe: function() {
                    alert('ALERT');
                },
                result: function() {
                    console.log("Method");
                    return this.counter2 > 5 ? "Greater than 5" : "Less than 5";
                }
            }
        });
    </script>
</html>